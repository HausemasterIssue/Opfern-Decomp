//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "C:\Users\u1\Documents\Java Decompiler\1.12 stable mappings"!

//Decompiled by Procyon!

package me.zeroeightsix.kami.module.modules.exploit;

import me.zeroeightsix.kami.module.*;
import net.minecraft.entity.*;
import net.minecraft.util.math.*;
import me.zeroeightsix.kami.setting.*;
import net.minecraft.entity.player.*;
import me.zeroeightsix.kami.command.*;
import java.util.*;

@Module.Info(name = "PearlExploit", category = Module.Category.EXPLOIT)
public class PearlExploit extends Module
{
    private Setting<Integer> range;
    private HashMap<Entity, Vec3d> knownPlayers;
    private HashMap<String, Vec3d> tpdPlayers;
    private int numTicks;
    private int numForgetTicks;
    
    public PearlExploit() {
        this.range = (Setting<Integer>)this.register((Setting)Settings.i("Range", 300));
        this.knownPlayers = new HashMap<Entity, Vec3d>();
        this.tpdPlayers = new HashMap<String, Vec3d>();
        this.numTicks = 0;
        this.numForgetTicks = 0;
    }
    
    public void onUpdate() {
        if (!this.isEnabled()) {
            return;
        }
        if (this.numTicks >= 50) {
            this.numTicks = 0;
            for (final Entity entity : PearlExploit.mc.world.loadedEntityList) {
                if (entity instanceof EntityPlayer && !entity.getName().equals(PearlExploit.mc.player.getName())) {
                    final Vec3d playerPos = new Vec3d((double)(int)entity.posX, (double)(int)entity.posY, (double)(int)entity.posZ);
                    if (this.knownPlayers.containsKey(entity)) {
                        if (Math.abs(this.knownPlayers.get(entity).distanceTo(playerPos)) > this.range.getValue() && Math.abs(PearlExploit.mc.player.getPositionVector().distanceTo(playerPos)) > this.range.getValue() * 2 && (!this.tpdPlayers.containsKey(entity.getName()) || this.tpdPlayers.get(entity.getName()) != playerPos)) {
                            Command.sendChatMessage("Player " + entity.getName() + " teleported to " + vectorToString(playerPos, new boolean[0]));
                            this.knownPlayers.remove(entity);
                            this.tpdPlayers.put(entity.getName(), playerPos);
                        }
                        this.knownPlayers.put(entity, playerPos);
                    }
                    else {
                        this.knownPlayers.put(entity, playerPos);
                    }
                }
            }
        }
        if (this.numForgetTicks >= 9000000) {
            this.tpdPlayers.clear();
        }
        ++this.numTicks;
        ++this.numForgetTicks;
    }
    
    private static String vectorToString(final Vec3d vector, final boolean... includeY) {
        final boolean reallyIncludeY = includeY.length <= 0 || includeY[0];
        final StringBuilder builder = new StringBuilder();
        builder.append('(');
        builder.append((int)Math.floor(vector.x));
        builder.append(", ");
        if (reallyIncludeY) {
            builder.append((int)Math.floor(vector.y));
            builder.append(", ");
        }
        builder.append((int)Math.floor(vector.z));
        builder.append(")");
        return builder.toString();
    }
}
